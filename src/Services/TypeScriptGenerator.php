<?php

declare(strict_types=1);

namespace DevWizardHQ\Enumify\Services;

use DevWizardHQ\Enumify\Data\EnumDefinition;
use DevWizardHQ\Enumify\Data\EnumMethodDefinition;

/**
 * Generates TypeScript code from PHP enum definitions.
 */
class TypeScriptGenerator
{
    public function __construct(
        private readonly string $exportStyle = 'enum',
        private readonly bool $generateUnionTypes = true,
        private readonly bool $generateLabelMaps = true,
        private readonly bool $generateMethodMaps = true,
    ) {}

    /**
     * Generate TypeScript content for an enum definition.
     */
    public function generate(EnumDefinition $enum): string
    {
        $lines = [];

        // Add file header
        $lines[] = '// This file is auto-generated by Laravel Enumify.';
        $lines[] = '// Do not edit this file manually.';
        $lines[] = '// @generated';
        $lines[] = '';

        if ($this->exportStyle === 'const') {
            $lines = array_merge($lines, $this->generateConstExport($enum));
        } else {
            $lines = array_merge($lines, $this->generateEnumExport($enum));
        }

        // Union type
        if ($this->generateUnionTypes) {
            $lines[] = '';
            $lines = array_merge($lines, $this->generateUnionType($enum));
        }

        // Label maps
        if ($this->generateLabelMaps && $enum->hasLabels()) {
            $lines[] = '';
            $lines = array_merge($lines, $this->generateLabelMap($enum));
        }

        // Custom method maps (color, isActive, etc.)
        if ($this->generateMethodMaps && $enum->hasMethods()) {
            foreach ($enum->methods as $method) {
                $lines[] = '';
                $lines = array_merge($lines, $this->generateMethodMap($enum, $method));
            }
        }

        $lines[] = '';

        return implode("\n", $lines);
    }

    /**
     * Generate TypeScript enum export style.
     *
     * @return array<string>
     */
    private function generateEnumExport(EnumDefinition $enum): array
    {
        $lines = [];
        $lines[] = "export enum {$enum->name} {";

        foreach ($enum->cases as $case) {
            $tsName = $case->getTypeScriptName();
            $tsValue = $case->getTypeScriptValue();
            $lines[] = "  {$tsName} = {$tsValue},";
        }

        $lines[] = '}';

        return $lines;
    }

    /**
     * Generate TypeScript const export style.
     *
     * @return array<string>
     */
    private function generateConstExport(EnumDefinition $enum): array
    {
        $lines = [];
        $lines[] = "export const {$enum->name} = {";

        foreach ($enum->cases as $case) {
            $tsName = $case->getTypeScriptName();
            $tsValue = $case->getTypeScriptValue();
            $lines[] = "  {$tsName}: {$tsValue},";
        }

        $lines[] = '} as const;';
        $lines[] = '';
        $lines[] = "export type {$enum->name} = typeof {$enum->name}[keyof typeof {$enum->name}];";

        return $lines;
    }

    /**
     * Generate union type for the enum.
     *
     * @return array<string>
     */
    private function generateUnionType(EnumDefinition $enum): array
    {
        if ($this->exportStyle === 'const') {
            // For const style, the type is already generated
            return [];
        }

        return [
            "export type {$enum->name}Value = `\${{$enum->name}}`;",
        ];
    }

    /**
     * Generate label map for the enum.
     *
     * @return array<string>
     */
    private function generateLabelMap(EnumDefinition $enum): array
    {
        $lines = [];
        $lines[] = "export const {$enum->name}Labels: Record<{$enum->name}, string> = {";

        foreach ($enum->cases as $case) {
            $tsName = $case->getTypeScriptName();
            $label = $case->label ?? $this->humanize($case->name);
            $escapedLabel = $this->escapeString($label);
            $lines[] = "  [{$enum->name}.{$tsName}]: \"{$escapedLabel}\",";
        }

        $lines[] = '};';

        return $lines;
    }

    /**
     * Generate a map for a custom method.
     *
     * @return array<string>
     */
    private function generateMethodMap(EnumDefinition $enum, EnumMethodDefinition $method): array
    {
        $lines = [];
        $tsType = $method->getTypeScriptType();
        $mapName = $this->getMethodMapName($enum->name, $method->name);

        $lines[] = "export const {$mapName}: Record<{$enum->name}, {$tsType}> = {";

        foreach ($enum->cases as $case) {
            $tsName = $case->getTypeScriptName();
            $value = $method->values[$case->name] ?? null;
            $tsValue = $this->formatValue($value);
            $lines[] = "  [{$enum->name}.{$tsName}]: {$tsValue},";
        }

        $lines[] = '};';

        // For boolean methods, also generate a helper function
        if ($method->isBooleanMethod()) {
            $lines[] = '';
            $lines = array_merge($lines, $this->generateBooleanHelper($enum, $method));
        }

        return $lines;
    }

    /**
     * Generate a helper function for boolean methods.
     *
     * @return array<string>
     */
    private function generateBooleanHelper(EnumDefinition $enum, EnumMethodDefinition $method): array
    {
        $funcName = $method->name;  // e.g., "isActive"
        $mapName = $this->getMethodMapName($enum->name, $method->name);

        return [
            "export function {$funcName}(value: {$enum->name}): boolean {",
            "  return {$mapName}[value];",
            '}',
        ];
    }

    /**
     * Get the TypeScript map name for a method.
     */
    private function getMethodMapName(string $enumName, string $methodName): string
    {
        // color -> CampusStatusColors
        // isActive -> CampusStatusIsActive
        $suffix = ucfirst($methodName);

        // Add 's' for non-boolean methods (e.g., Colors, not Booleans)
        if (! str_starts_with($methodName, 'is') && ! str_starts_with($methodName, 'can') && ! str_starts_with($methodName, 'has')) {
            $suffix .= 's';
        }

        return $enumName.$suffix;
    }

    /**
     * Format a PHP value for TypeScript output.
     */
    private function formatValue(mixed $value): string
    {
        if ($value === null) {
            return 'null';
        }

        if (is_bool($value)) {
            return $value ? 'true' : 'false';
        }

        if (is_int($value) || is_float($value)) {
            return (string) $value;
        }

        if (is_string($value)) {
            return '"'.$this->escapeString($value).'"';
        }

        return 'null';
    }

    /**
     * Convert SCREAMING_SNAKE_CASE to human-readable text.
     */
    private function humanize(string $value): string
    {
        return ucwords(strtolower(str_replace('_', ' ', $value)));
    }

    /**
     * Escape a string for use in TypeScript.
     */
    private function escapeString(string $value): string
    {
        return str_replace(
            ['\\', '"', "\n", "\r", "\t"],
            ['\\\\', '\"', '\n', '\r', '\t'],
            $value
        );
    }

    /**
     * Generate barrel index file content.
     *
     * @param  array<EnumDefinition>  $enums
     */
    public function generateBarrel(array $enums, string $fileCase): string
    {
        $lines = [];
        $lines[] = '// This file is auto-generated by Laravel Enumify.';
        $lines[] = '// Do not edit this file manually.';
        $lines[] = '// @generated';
        $lines[] = '';

        foreach ($enums as $enum) {
            $filename = $enum->getFilename($fileCase);
            $lines[] = "export * from './{$filename}';";
        }

        $lines[] = '';

        return implode("\n", $lines);
    }
}
